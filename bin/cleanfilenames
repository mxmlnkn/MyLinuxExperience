#!/bin/bash
# cleanes filename of files in current folder and its subdirectories
# no target directory or file argument possible at the moment


# takes piped input!
cleanFilenames() {
    # Windows restrictions: https://msdn.microsoft.com/en-us/library/aa493942%28v=exchg.80%29.aspx
    #    / \ * ? < > |
    #    \x22->\x27 makes: double quote -> single quote
    #    pipestroke -> hyphen
    #    double quote -> single quote
    # Change HTML-Codes:
    #    &#039; -> '
    #    here is how to correct html codes in existing folder names:
    #       find /media/m -type d -execdir bash -c 'if grep -q "&#039;" <(echo '"'{}'"'); then newname=$(printf "%s" '"'{}'"' | sed "s/&#039;/'"'"'/g"); echo mv "{}"; echo " -> $newname"; mv "{}" "$newname"; fi' \;
    # Use printf instead of echo to make it work for file names starting with e.g. '-e'
    sed -r '
        # $! - If its not a end of file.
        # N  - Append the next line with the pattern space delimited by \n
        # b  - jump to label
        :a
            N
        $!b a
        s/\n/ /g
        # for some reason s/\r//g wouldnt work now :S, that is why it is piped to another sed
    ' | sed -r '
        s/[|/\:]/ - /g;
        s|â€”|-|g;
        s/\x22/\x27/g;
        # .html.mht -> .mht
        s/\.html\.mht/\.mht/g;
        s/[*?<>$]/_/g;
        # delete dots at the end of line
        s/\.+$//;
        s/&#039;/'"'"'/g;
        s|&lt;||g;
        s|&gt;||g;
        s|&amp;| and |g;
        # delete leading spaces
        s/^ +//g;
        # delete white spaces at end of file name
        s/ +$//g;
        # delete newlines and returns and other non-printables
        s/[\x01-\x1F\x7F]/ /g;
        s|\t| |g;
        s|[ \t]+| |g;
        # convert extensions to lowercase
        s|(\.[A-Za-z0-9]{3})$|\L\1|;
        # some other obnoxious extensions
        s|\.jpeg$|.jpg|;
    '
}

##################################### Main #####################################

dryrun=0
dir=.
while [ "$1" != "" ]; do
  case $1 in
    "-r" | "--dry-run")
      dryrun=1
      ;;
    *)  # default case (neither one of the options from above, nor empty)
        if [ ${1:0:1} == '-' ]; then
            echo "Wrong parameters specified! (\$1=$1)"
            exit 1
        else
            dir="$1"
            break
        fi
        ;;
  esac
  shift
done

export -f cleanFilenames
FIND=( find "$dir" -type f )
${FIND[@]} -print0 | pv -0lps $(${FIND[@]} | wc -l) | xargs -0 -I {} -P 4 bash -c '
    # use here-doc in order to not have any undefined behavior caused by
    # special characters
    path=$(cat << "EOF"
{}
EOF
    )
    name=$(basename "$path")
    cd "$(dirname "$path")"
    newname=$(printf "%s" "$name" | cleanFilenames)
    mime=$(file --mime "$newname" | sed -r "s|.*: ([^;]*); .*|\1|")
    # http://www.iana.org/assignments/media-types/media-types.xhtml
    # /etc/mime.types
    case "$mime" in
        image/gif                  ) mext=gif   ;;
        image/jpeg                 ) mext=jpg   ;;
        image/png                  ) mext=png   ;;
        image/tiff                 ) mext=tiff  ;;
        image/vnd.djvu             ) mext=djvu  ;;
        image/x-icon               ) mext=ico   ;;
        image/x-ms-bmp             ) mext=bmp   ;;
        application/x-7z-compressed) mext=7z    ;;
        application/octet-stream   ) mext=lzma  ;;
        application/x-rar          ) mext=rar   ;;
        application/x-tar          ) mext=tar   ;;
        application/x-bzip2        ) mext=bzip2 ;;
        application/gzip           ) mext=gzip  ;;
        application/x-xz           ) mext=xz    ;;
        application/zip            ) mext=zip   ;;
        *                          ) mext=      ;;
    esac
    ext=${newname##*.}
    #echo "$name -> ext: $ext -> mime: $mime -> mext: $mext"
    # this means it most probable is actually the extension and not something
    # different like a word after a full stop or decimal point
    if [ ${#ext} -le 3 ] && [ ! -z "$mext" ]; then
        newname=${newname%.*}.$mext
    elif [ ! -z "$mext" ]; then
        newname=$newname.$mext
    fi
    if [ ! -z "$newname" ] && [ "$name" != "$newname" ]; then
        echo "rename: $(realpath "$name")"
        echo " -> to: $(realpath "$newname")"
        if [ ! "'$dryrun'" -eq 1 ]; then
            mv "$name" "$newname"
        fi
    fi
' \;
