#!/bin/bash
# cleanes filename of files in current folder and its subdirectories
# no target directory or file argument possible at the moment


# takes piped input!
cleanFilenames() {
    # Windows restrictions: https://msdn.microsoft.com/en-us/library/aa493942%28v=exchg.80%29.aspx
    #    / \ * ? < > |
    #    \x22->\x27 makes: double quote -> single quote
    #    pipestroke -> hyphen
    #    double quote -> single quote
    # Change HTML-Codes:
    #    &#039; -> '
    #    here is how to correct html codes in existing folder names:
    #       find /media/m -type d -execdir bash -c 'if grep -q "&#039;" <(echo '"'{}'"'); then newname=$(printf "%s" '"'{}'"' | sed "s/&#039;/'"'"'/g"); echo mv "{}"; echo " -> $newname"; mv "{}" "$newname"; fi' \;
    # Use printf instead of echo to make it work for file names starting with e.g. '-e'
    sed -r '
        # $! - If its not a end of file.
        # N  - Append the next line with the pattern space delimited by \n
        # b  - jump to label
        :a
            N
        $!b a
        s/\n/ /g
        # for some reason s/\r//g wouldnt work now :S, that is why it is piped to another sed
    ' | sed -r '
        s/[|/\:]/ - /g;
        s|â€”|-|g;
        s/\x22/\x27/g;
        # .html.mht -> .mht
        s/\.html\.mht/\.mht/g;
        s/[*?<>$]/_/g;
        # delete dots at the end of line
        s/\.+$//g;
        s/&#039;/'"'"'/g;
        s|&lt;||g;
        s|&gt;||g;
        s|&amp;| and |g;
        # delete leading spaces
        s/^ +//g;
        # delete white spaces at end of file name
        s/ +$//g;
        # delete newlines and returns and other non-printables
        s/[\x01-\x1F\x7F]/ /g;
        s|\t| |g;
        s|[ \t]+| |g;
        # convert hex codes
        s|%20| |g;
        # convert extensions to lowercase
        s|(\.[A-Za-z0-9]{3})$|\L\1|;
        # some other obnoxious extensions
        s|\.jpeg$|.jpg|;
        s|\.png\.jpg|.jpg|;
        s|\.jpg\.png|.png|;
    '
}

##################################### Main #####################################

dryrun=0
dir=.
while [ "$1" != "" ]; do
  case $1 in
    "-r" | "--dry-run")
      dryrun=1
      ;;
    *)  # default case (neither one of the options from above, nor empty)
        if [ ${1:0:1} == '-' ]; then
            echo "Wrong parameters specified! (\$1=$1)"
            exit 1
        else
            dir="$1"
            break
        fi
        ;;
  esac
  shift
done

export -f cleanFilenames
FIND=( find "$dir" -type f )
echo -n "Counting how many files need to be checked ... "
# if ${FIND[@]} is unqoted, then spaces in $dir will cause problems
nFiles=$("${FIND[@]}" | wc -l)
echo "$nFiles"
"${FIND[@]}" -print0 | pv -0lps $nFiles | xargs -0 -I {} -P 4 bash -c '
    # use here-doc in order to not have any undefined behavior caused by
    # special characters
    path=$(cat << "EOF"
{}
EOF
    )
    name=$(basename "$path")
    cd "$(dirname "$path")"
    newname=$(printf "%s" "$name" | cleanFilenames)
    mime=$(file --mime -- "$name" | sed -r "s|.*: ([^;]*); .*|\1|")
    # http://www.iana.org/assignments/media-types/media-types.xhtml
    # /etc/mime.types
    case "$mime" in
        image/gif                  ) mext=gif   ;;
        image/jpeg                 ) mext=jpg   ;;
        image/png                  ) mext=png   ;;
        image/tiff                 ) mext=tif   ;;
        image/vnd.djvu             ) mext=djvu  ;;
        image/x-icon               ) mext=ico   ;;
        image/x-ms-bmp             ) mext=bmp   ;;
        application/x-7z-compressed) mext=7z    ;;
        # octet stream means the file type was not recognized!
        # application/octet-stream   ) mext=lzma  ;;
        application/x-rar          ) mext=rar   ;;
        application/x-tar          ) mext=tar   ;;
        application/x-bzip2        ) mext=bz2   ;;
        application/gzip           ) mext=gz    ;;
        application/x-xz           ) mext=xz    ;;
        application/zip            ) mext=zip   ;;
        *                          ) mext=      ;;
    esac

    # Remove extension duplicates e.g. a.png.png.png -> a.png
    # Ignore digit-only extensions, e.g. libssl.so.1.0.0
    ext=${newname##*.}
    if [ "$ext" == "$newname" ]; then
        ext=
    fi
    newNameWoExt=${newname%.*}
    while [ ! -z "$ext" ] && [ ${#ext} -le 4 ] &&
          [ "${newNameWoExt##*.}" == "$ext" ] &&
          [ "${newNameWoExt%.*}" != "$newNameWoExt" ] &&
          ! [ "$ext" -eq "$ext" ] 2>/dev/null  # if not number
    do
        ext=${newNameWoExt##*.}
        newNameWoExt=${newNameWoExt%.*}
    done
    if [ -z "$ext" ]; then
        newname=${newNameWoExt}
    else
        newname=${newNameWoExt}.$ext
    fi

    # change README.README back to README (cause by old bug in this script)
    #if [ "${newname%.*}" == "${newname##*.}" ]; then
    #    newname=${newname%.*}
    #fi

    # this means it most probably is actually the extension and not something
    # different like a word after a full stop or decimal point
    if [ ${#ext} -le 4 ] && [ "$ext" != "$mext" ] && [ ! -z "$mext" ]; then
        newname=${newname%.*}.$mext
    elif [ "$ext" != "$mext" ] && [ ! -z "$mext" ]; then
        # if the old extension is longer than 4 characters, just append the new extension
        newname=$newname.$mext
    fi
    if [ ! -z "$newname" ] && [ "$name" != "$newname" ]; then
        # $name -> ext: $ext -> mime: $mime -> mext: $mext\n
        echo -e "rename: $(realpath "$name")\n -> to: $(realpath "$newname")"
        if [ ! "'$dryrun'" -eq 1 ]; then
            mv "$name" "$newname"
        fi
    fi
' \;
